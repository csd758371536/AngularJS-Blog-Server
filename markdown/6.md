读完上一本DOM编程艺术后，认识了一些网页常见的DOM操作，那么接下来就该对JavaScript语言本身进行一个系统的学习了。要全面学习JavaScript，最快的办法还是读书，所以我选择了这本《JavaScript高级程序设计》，因为它在业内被誉为前端必读的经典书籍之一，而且也算入门的必备书了，非常有细细研读的价值。

<!--more-->

## 第一章：JavaScript简介
第一章的前半段主要对JavaScript的历史进行了简单回顾，后半段介绍了它的版本以及和ECMAScript的关系。
历史介绍方面没什么好讲的，读者可自行翻阅，后半段JavaScript实现部分的内容可用一张图作为概括：

![JavaScript实现](https://i.loli.net/2017/11/07/5a0110aeb73ff.png)

## 第二章：在HTML中使用JavaScript
### script元素
在通过&lt;script&gt;标签嵌入JavaScript代码时，代码中不能出现“&lt;/script&gt;”字符串，通过转义字符解决：
```html
<script type="text/javascript">
    function sayScript(){
        alert("<\/script>");
    }
</script>
```

### 延迟脚本
defer属性表明脚本会被延迟到整个页面都解析完毕后再运行（浏览器遇到&lt;/html&gt;标签之后）
```html
<script type="text/javascript" defer="defer" src="example1.js"></script>
```
> 注：defer属性只适用于外部脚本文件

### 异步脚本
指定async属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容
```html
<script type="text/javascript" async src="example1.js"></script>
```
> 注：async属性只适用于外部脚本文件

### 在XHTML中的用法
在XHTML中小于号（<）会被当做一个开始标签来解析，可以用相应的HTML实体来替换代码中的小于号：
```html
<script type="text/javascript">
function compare(a, b) {
    if (a &lt; b) {
        alert("A is less than B");
    } else if (a > b) {
        alert("A is greater than B");
    } else {
        alert("A is equal to B");
    }
}
</script>
```
或者利用CDATA片段，它表示文档中的特殊区域：
```html
<script type="text/javascript">
//<![CDATA[
function compare(a, b) {
    if (a < b) {
        alert("A is less than B");
    } else if (a > b) {
        alert("A is greater than B");
    } else {
        alert("A is equal to B");
    }
}
//]]>
</script>
```
> 注释CDATA可以确保在不兼容XHTML的浏览器中也能正常使用

### noscript元素
利用&lt;noscript&gt;在不支持JavaScript的浏览器中显示替代的内容：
```html
<noscript>
    <p>本页面需要浏览器支持（启用）JavaScript。</p>
</noscript>
```

## 第三章：基本概念
### 标识符
标识符指变量、函数、函数参数、属性的名字，规则如下：
- 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）
- 其他字符可以是字母、下划线、美元符号或数字

> 注：不能把关键字、保留字、true、false和null用作标识符

### 变量
用var操作符定义的变量将成为定义该变量的作用域中的局部变量：
```javascript
function test(){
    var message = "hi"; // 局部变量
}
test();
alert(message); // 错误！
```
省略var后，message就成了全局变量：（不推荐的做法）
```javascript
function test(){
    var message = "hi"; // 全局变量
}
test();
alert(message); // "hi"
```
> 在严格模式下，不能定义名为`eval`或`arguments`的变量，否则会导致语法错误。

### 数据类型
基本数据类型：
`Undefined`、`Null`、`Boolean`、`Number`、`String`

复杂数据类型：
`Object`

#### typeof
使用操作符`typeof`可以检测给定变量的数据类型，返回的字符串结果及解释如下：

undefined | boolean | string | number | object     | function
----------|---------|--------|--------|------------|---------
未定义    | 布尔值  | 字符串 | 数值   | 对象或null | 函数

> 调用`typeof null`会返回`object`，因为特殊值`null`被认为是一个空的对象引用

#### undefined
只声明但未初始化变量或者初始化为undefined，变量的类型都将为undefined：
```javascript
var message;
alert(message == undefined); // true

var message = undefined;
alert(message == undefined); // true
```
变量未声明时，使用typeof操作符后返回的结果也将为undefined：
```javascript
var message; // 这个变量声明之后默认取得了undefined值
// 下面这个变量并没有声明
// var age;
alert(typeof message); // "undefined"
alert(typeof age); // "undefined"
```

#### Null
null值表示空对象指针，也就是说null也是一个对象：
```javascript
var car = null;
alert(typeof car); // "object"
```
如果定义的变量准备用来保存对象，就应该明确的让变量初始化为null，这样可以与默认初始化的undefined值区分开：
```javascript
if (car != null){
// 对car对象执行某些操作
}
```
undefined值派生自null：
```javascript
alert(null == undefined); // true
```

#### Boolean
true、false和数字值不同，true不一定等于1，false不一定等于0

区分大小写，True和False不是Boolean值

可以对任何数据类型的值调用Boolean()函数，它总会返回一个Boolean值：

数据类型 | 转换为true的值 | 转换为false的值
---------|----------------|----------------
Boolean  | true           | false
String   | 任何非空字符串 | ""（空字符串）
Number   | 任何非零数字值 | 0和NaN
Object   | 任何对象       | null
Undefined| n/a            | undefined

#### Number
##### 整数
数值字面量格式可以是十进制、八进制或十六进制整数：
```javascript
var intNum = 55; // 整数
var octalNum1 = 070; // 八进制的 56
var octalNum2 = 079; // 无效的八进制数值——解析为 79
var octalNum3 = 08; // 无效的八进制数值——解析为 8
var hexNum1 = 0xA; // 十六进制的 10
var hexNum2 = 0x1f; // 十六进制的 31
```
JavaScript中可以保存+0和-0这两种数值，并且它们相等：
```javascript
+0 == -0 // true
```

##### 浮点数
ECMAScript会不失时机地将浮点数值转换为整数值：
```javascript
var floatNum1 = 1.; // 小数点后面没有数字——解析为 1
var floatNum2 = 10.0; // 整数——解析为 10
```
极小或者极大的数值可以用e表示法：
```javascript
var floatNum1 = 3.125e7; // 等于 31250000
var floatNum2 = 3e-17 // 等于 0.00000000000000003
```
浮点数值的最高精度是17位小数，浮点数值计算会产生舍入误差的问题：
```javascript
0.1 + 0.2 // 等于 0.30000000000000004
```

##### MIN_VALUE、MAX_VALUE
ECMAScript能够表示的最小数值与最大数值：
```javascript
Number.MIN_VALUE // 5e-324
Number.MAX_VALUE // 1.7976931348623157e+308
```

##### Infinity
超过数值范围的值会被转化为-Infinity（负无穷）或者Infinity（正无穷）
```javascript
Number.NEGATIVE_INFINITY = -Infinity
Number.POSITIVE_INFINITY = Infinity
```
使用`isFinite()`可以确定一个数值是否在最大和最小数值之间：
```javascript
var result = Number.MAX_VALUE + Number.MAX_VALUE;
alert(isFinite(result)); // false
```

##### NaN
在ECMAScript中，0除以0返回NaN，正数和负数除以0返回Infinity和-Infinity
除此之外，它还有两个特点：
> 任何涉及NaN的操作都会返回NaN
> NaN与任何值都不相等，包括它本身

利用`isNaN()`可以判断一个参数是否“不是数值”，它会尝试将这个值转化为数值：
```javascript
alert(isNaN(NaN)); // true
alert(isNaN(10)); // false（10 是一个数值）
alert(isNaN("10")); // false（可以被转换成数值 10）
alert(isNaN("blue")); // true（不能转换成数值）
alert(isNaN(true)); // false（可以被转换成数值 1）
```

##### 数值转换
`Number()`可以用于任何数据类型，`parseInt()`和`parseFloat()`则专门用于将字符串转化为数值，`Number()`的转换规则如下：
- 如果是Boolean值，true和false将分别被转换为1和0
- 如果是数字值，只是简单的传入和返回
- 如果是null值，返回0
- 如果是undefined，返回NaN
- 如果是字符串，遵循以下原则：
 1. 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即 "1"会变成 1，"123"会变成 123，而"011"会变成11（注意：前导的零被忽略了）
 2. 如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值（同样，也会忽略前导零）
 3. 如果字符串中包含有效的十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整数值
 4. 如果字符串是空的（不包含任何字符），则将其转换为 0
 5. 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN
- 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换
的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符
串值

`Number()`转换的例子如下：
```javascript
var num1 = Number("Hello world!"); // NaN
var num2 = Number(""); // 0
var num3 = Number("000011"); // 11
var num4 = Number(true); // 1
```
`parseInt()`的转换规则如下：
- 转换字符串时，更多的是看其是否符合数值模式，它会忽略字符串前面的空格，直至找到第一个非空格字符
- 如果第一个字符不是数字字符或者负号，返回NaN
- 如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符
- 如果字符串中的第一个字符是数字字符，parseInt()也能够识别出各种整数格式

`parseInt()`转换的例子如下：
```javascript
var num1 = parseInt("1234blue"); // 1234
var num2 = parseInt(""); // NaN
var num3 = parseInt("0xA"); // 10（十六进制数）
var num4 = parseInt(22.5); // 22
var num5 = parseInt("070"); // 56（八进制数）
var num6 = parseInt("70"); // 70（十进制数）
var num7 = parseInt("0xf"); // 15（十六进制数）
```
解析像八进制字面量的字符串时，ECMAScript3和5存在分歧，因此需要指定转换时使用的基数：
```javascript
var num = parseInt("0xAF", 16); // 175
var num1 = parseInt("AF", 16); // 省略0x后就必须指定基数
var num2 = parseInt("AF"); // NaN
```
`parseFloat()`的转换规则如下：
- 从第一个字符（位置0）开始解析每个字符。而且一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止（字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略）
- 始终都会忽略前导的零

典型示例：
```javascript
var num1 = parseFloat("1234blue"); // 1234（整数）
var num2 = parseFloat("0xA"); // 0
var num3 = parseFloat("22.5"); // 22.5
var num4 = parseFloat("22.34.5"); // 22.34
var num5 = parseFloat("0908.5"); // 908.5
var num6 = parseFloat("3.125e7"); // 31250000
```

#### String
String数据类型包含的转义序列如下：

字面量 | 含义 
-------|-----
\n     | 换行
\t     | 制表
\b     | 空格
\r     | 回车
\f     | 进纸
\&#92; | 斜杠
\'     | 单引号
\"     | 双引号
\xnn   | 以十六进制代码 nn 表示的一个字符（其中n为0～F）。例如，\x41表示"A"
\unnnn | 以十六进制代码nnnn表示的一个Unicode字符（其中n为0～F）。例如，\u03a3表示希腊字符Σ

数值、布尔值、对象和字符串值都有`toString()`方法，null和undefined值没有这个方法。
在调用数值的这个方法时，可以指定输出数值的基数：
```javascript
var num = 10;
alert(num.toString()); // "10"
alert(num.toString(2)); // "1010"
alert(num.toString(8)); // "12"
alert(num.toString(10)); // "10"
alert(num.toString(16)); // "a"
```
转型函数String()可以将任何类型的值转换为字符串，转换规则如下：
- 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果
- 如果值是null，则返回"null"
- 如果值是undefined，则返回"undefined"

```javascript
var value1 = 10;
var value2 = true;
var value3 = null;
var value4;
alert(String(value1)); // "10"
alert(String(value2)); // "true"
alert(String(value3)); // "null"
alert(String(value4)); // "undefined"
```

#### Object
利用new操作符来创建一个对象的实例：
```javascript
var o = new Object();
```
Object是所有对象的基础，它具有如下属性和方法：
- constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数`constructor`就是Object()
- hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty("name")）
- isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型
- propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定
- toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应
- toString()：返回对象的字符串表示
- valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值
相同

### 操作符
#### 一元递增和递减
前置递增和递减操作时，变量的值都是在语句被求值以前改变的：
```javascript
var age = 29;
var anotherAge = --age + 2;
alert(age); // 输出 28
alert(anotherAge); // 输出 30
```
后置递增和递减操作是在包含它们的语句被求值之后才执行的：
```javascript
var num1 = 2;
var num2 = 20;
var num3 = num1-- + num2; //  等于 22
var num4 = num1 + num2; // 等于 21
```
在应用于不同的值时，递增和递减操作符遵循下列规则：
- 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减1的操作。字符串变量变成数值变量
- 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN。字符串变量变成数值变量
- 在应用于布尔值false时，先将其转换为0再执行加减1的操作。布尔值变量变成数值变量
- 在应用于布尔值true时，先将其转换为1再执行加减1的操作。布尔值变量变成数值变量
- 在应用于浮点数值时，执行加减1的操作
- 在应用于对象时，先调用对象的valueOf()方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是NaN，则在调用toString()方法后再应用前述规则。对象变量变成数值变量

示例如下：
```javascript
var s1 = "2";
var s2 = "z";
var b = false;
var f = 1.1;
var o = {
    valueOf: function() {
        return -1;
    }
};
s1++; // 值变成数值 3
s2++; // 值变成 NaN
b++; // 值变成数值 1
f--; // 值变成 0.10000000000000009（由于浮点舍入错误所致）
o--; // 值变成数值-2
```

#### 一元加和减
对非数值应用一元加和减操作符时，会向会像Number()转型函数一样对这个值执行转换：
```javascript
var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;
var f = 1.1;
var o = {
    valueOf: function() {
        return -1;
    }
};
s1 = +s1; // 值变成数值 1
s2 = +s2; // 值变成数值 1.1
s3 = +s3; // 值变成 NaN
b = +b; // 值变成数值 0
f = +f; // 值未变，仍然是 1.1
o = +o; // 值变成数值-1
```
一元减操作符应用时，和一元加一样，不过最后会将得到的数值转换成负数：
```javascript
var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;
var f = 1.1;
var o = {
    valueOf: function() {
        return -1;
    }
};
s1 = -s1; // 值变成了数值-1
s2 = -s2; // 值变成了数值-1.1
s3 = -s3; // 值变成了 NaN
b = -b; // 值变成了数值 0
f = -f; // 变成了-1.1
o = -o; // 值变成了数值 1
```

#### 位操作符
##### 按位非
操作数的负值减1：
```javascript
var num1 = 25; // 二进制 00000000000000000000000000011001
var num2 = ~num1; // 二进制 11111111111111111111111111100110
alert(num2); // -26
```

##### 按位与
两个数值的对应位都是1时才返回1，任何一位是0，结果都是0：
```javascript
var result = 25 & 3;
alert(result); // 1
```
25 = 0000 0000 0000 0000 0000 0000 0001 1001
3 = 0000 0000 0000 0000 0000 0000 0000 0011
AND = 0000 0000 0000 0000 0000 0000 0000 0001

##### 按位或
有一个位是1的情况下就返回1，而只有在两个位都是0的情况下才返回0：
```javascript
var result = 25 | 3;
alert(result); // 27
```
25 = 0000 0000 0000 0000 0000 0000 0001 1001
3 = 0000 0000 0000 0000 0000 0000 0000 0011
OR = 0000 0000 0000 0000 0000 0000 0001 1011

##### 按位异或
两个数值对应位上只有一个1时才返回1，如果对应的两位都是1或都是0，则返回0：
```javascript
var result = 25 ^ 3;
alert(result); // 26
```
25 = 0000 0000 0000 0000 0000 0000 0001 1001
3 = 0000 0000 0000 0000 0000 0000 0000 0011
XOR = 0000 0000 0000 0000 0000 0000 0001 1010

##### 左移
将数值的所有位向左移动指定的位数：
```javascript
var oldValue = 2; // 等于二进制的 10
var newValue = oldValue << 5; // 等于二进制的 1000000，十进制的 64
```

##### 有符号的右移
将数值向右移动，但保留符号位（即正负号标记）：
```javascript
var oldValue = 64; // 等于二进制的 1000000
var newValue = oldValue >> 5; // 等于二进制的 10 ，即十进制的 2
```

##### 无符号右移
以0来填充空位，而不是像有符号右移那样以符号位的值来填充空位，并且无符号右移操作符会把负数的二进制码当成正数的二进制码：
```javascript
var oldValue = -64; // 等于二进制的 11111111111111111111111111000000
var newValue = oldValue >>> 5; // 等于十进制的 134217726
```

#### 布尔操作符
##### 逻辑非
逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反：
```javascript
alert(!false); // true
alert(!"blue"); // false
alert(!0); // true
alert(!NaN); // true
alert(!""); // true
alert(!12345); // false
```
同时使用两个逻辑非操作符，实际上就会模拟`Boolean()`转型函数的行为：
```javascript
alert(!!"blue"); // true
alert(!!0); // false
alert(!!NaN); // false
alert(!!""); // false
alert(!!12345); // true
```

##### 逻辑与
有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值：
- 如果第一个操作数是对象，则返回第二个操作数
- 如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象
- 如果两个操作数都是对象，则返回第二个操作数
- 如果有一个操作数是null，则返回null
- 如果有一个操作数是NaN，则返回NaN
- 如果有一个操作数是undefined，则返回undefined

如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值：
```javascript
var found = true;
var result = (found && someUndefinedVariable); // 这里会发生错误
alert(result); // 这一行不会执行

var found = false;
var result = (found && someUndefinedVariable); // 不会发生错误
alert(result); // 会执行（"false"）
```

##### 逻辑或
如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值：
- 如果第一个操作数是对象，则返回第一个操作数
- 如果第一个操作数的求值结果为false，则返回第二个操作数
- 如果两个操作数都是对象，则返回第一个操作数
- 如果两个操作数都是null，则返回null
- 如果两个操作数都是NaN，则返回NaN
- 如果两个操作数都是undefined，则返回undefined

如果第一个操作数的求值结果为true，就不会对第二个操作数求值了：
```javascript
var found = true;
var result = (found || someUndefinedVariable); // 不会发生错误
alert(result); // 会执行（"true"）

var found = false;
var result = (found || someUndefinedVariable); // 这里会发生错误
alert(result); // 这一行不会执行
```

#### 乘性操作符
##### 乘法
在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：
- 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity
- 如果有一个操作数是NaN，则结果是NaN
- 如果是Infinity与0相乘，则结果是NaN
- 如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数
的符号
- 如果是Infinity与Infinity相乘，则结果是Infinity
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则

##### 除法
除法操作符对特殊的值也有特殊的处理规则：
- 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity
- 如果有一个操作数是NaN，则结果是NaN
- 如果是Infinity被Infinity除，则结果是NaN
- 如果是零被零除，则结果是NaN
- 如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号
- 如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则

##### 求模
求模操作符会遵循下列特殊规则来处理特殊的值：
- 如果操作数都是数值，执行常规的除法计算，返回除得的余数
- 如果被除数是无穷大值而除数是有限大的数值，则结果是NaN
- 如果被除数是有限大的数值而除数是零，则结果是NaN
- 如果是Infinity被Infinity除，则结果是NaN
- 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数
- 如果被除数是零，则结果是零
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则

#### 加性操作符
##### 加法
如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：
- 如果有一个操作数是NaN，则结果是NaN
- 如果是Infinity加Infinity，则结果是Infinity
- 如果是-Infinity加-Infinity，则结果是-Infinity
- 如果是Infinity加-Infinity，则结果是NaN
- 如果是+0加+0，则结果是+0
- 如果是0加0，则结果是0
- 如果是+0加0，则结果是+0

如果有一个操作数是字符串：
- 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来
- 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来

> 如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值。
> 对于undefined和null，则分别调用String()函数并取得字符串"undefined"和"null"。

##### 减法
与加法操作符类似，减法操作符在处理各种数据类型转换时，同样需要遵循一些特殊规则：
- 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果
- 如果有一个操作数是NaN，则结果是NaN
- 如果是Infinity减Infinity，则结果是NaN
- 如果是-Infinity减-Infinity，则结果是NaN
- 如果是Infinity减-Infinity，则结果是Infinity
- 如果是-Infinity减Infinity，则结果是-Infinity
- 如果是+0减+0，则结果是+0
- 如果是+0减0，则结果是0
- 如果是0减0，则结果是+0
- 如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN
- 如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值

```javascript
var result1 = 5 - true; // 4，因为 true 被转换成了 1
var result2 = NaN - 1; // NaN
var result3 = 5 - 3; // 2
var result4 = 5 - ""; // 5，因为"" 被转换成了 0
var result5 = 5 - "2"; // 3，因为"2"被转换成了 2
var result6 = 5 - null; // 5，因为 null 被转换成了 0
```

#### 关系操作符
当关系操作符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作：
- 如果两个操作数都是数值，则执行数值比较
- 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值
- 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较
-  如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有valueOf()方法，则调用toString()方法，并用得到的结果根据前面的规则执行比较
- 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较

要真正按字母表顺序比较字符串，就必须把两个操作数转换为相同的大
小写形式（全部大写或全部小写）：
```javascript
var result = "Brick".toLowerCase() < "alphabet".toLowerCase(); //false
```
任何操作数与NaN进行关系比较，结果都是false：
```javascript
var result1 = NaN < 3; //false
var result2 = NaN >= 3; //false
```

#### 相等操作符
##### 相等和不相等
"=="和"!="都会先转换操作数，然后再比较它们的相等性。在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：
- 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1
- 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值
- 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较

这两个操作符在进行比较时则要遵循下列规则：
- null和undefined是相等的
- 要比较相等性之前，不能将null和undefined转换成其他任何值
- 如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true 。重要提示：即使两个操作数都是NaN，相等操作符也返回false；因为按照规则，NaN不等于NaN
- 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false

下表列出了一些特殊情况及比较结果：

表达式 | 值
-------|-----
null == undefined | true
"NaN" == NaN | false
5 == NaN | false
NaN == NaN | false
NaN != NaN | true
false == 0 | true
true == 1 | true
true == 2 | false
undefined == 0 | false
null == 0 | false
"5"==5 | true

##### 全等和不全等
"==="和"!=="在比较之前不转换操作数，它们只在两个操作数未经转换就相等或不相等的情况下返回true：
```javascript
var result1 = ("55" == 55); //true，因为转换后相等
var result2 = ("55" === 55); //false，因为不同的数据类型不相等

var result1 = ("55" != 55); //false，因为转换后相等
var result2 = ("55" !== 55); //true，因为不同的数据类型不相等
```
> null==undefined会返回true，因为它们是类似的值；但null === undefined会返回false，因为它们是不同类型的值。

#### 条件操作符
variable = boolean_expression ? true_value : false_value;

#### 逗号操作符
在用于赋值时，逗号操作符总会返回表达式中的最后一项：
```javascript
var num = (5, 1, 4, 8, 0); // num 的值为 0
```

### 语句
#### if语句
```javascript
if (condition) statement1 else statement2
```
其中的condition（条件）可以是任意表达式，对这个表达式求值的结果不一定是布尔值。ECMAScript 会自动调用Boolean()转换函数将这个表达式的结果转换为一个布尔值。

#### for语句
ECMAScript中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到：
```javascript
var count = 10;
for (var i = 0; i < count; i++) {
    alert(i);
}
alert(i); // 10
```

#### for-in语句
```javascript
for (var propName in window) {
    document.write(propName);
}
```
ECMAScript对象的属性没有顺序，如果表示要迭代的对象的变量值为null或undefined，将不执行循环体。

#### label语句
```javascript
start: for (var i = 0; i < count; i++) {
    alert(i);
}
```

#### break和continue语句
它们可以和label语句联用：
```javascript
var num = 0;
outermost:
for (var i=0; i < 10; i++) {
    for (var j=0; j < 10; j++) {
        if (i == 5 && j == 5) {
            break outermost;
        }
        num++;
    }
}
alert(num); //55

var num = 0;
outermost:
for (var i=0; i < 10; i++) {
    for (var j=0; j < 10; j++) {
        if (i == 5 && j == 5) {
            continue outermost;
        }
        num++;
    }
}
alert(num); //95
```

### 函数
严格模式对函数有一些限制：
- 不能把函数命名为eval或arguments
- 不能把参数命名为eval或arguments
- 不能出现两个命名参数同名的情况

ECMAScript函数不能像传统意义上那样实现重载，因为其参数是由包含零或多个值的数组来表示的：
```javascript
function addSomeNumber(num){
    return num + 100;
}
function addSomeNumber(num) {
    return num + 200;
}
var result = addSomeNumber(100); // 300
```
如果在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。
通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载：
```javascript
function doAdd() {
    if(arguments.length == 1) {
        alert(arguments[0] + 10);
    } else if (arguments.length == 2) {
        alert(arguments[0] + arguments[1]);
    }
}
doAdd(10); //20
doAdd(30, 20); //50
```

## 第四章：变量、作用域和内存问题
### 基本类型和引用类型的值
当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象。

#### 动态的属性
只能给引用类型值动态地添加属性，不能给基本类型的值添加属性：
```javascript
var person = new Object();
person.name = "Nicholas";
alert(person.name); //"Nicholas"

var name = "Nicholas";
name.age = 27;
alert(name.age); //undefined
```

#### 复制变量值
从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上：
```javascript
var num1 = 5;
var num2 = num1;
```
从一个变量向另一个变量复制引用类型的值时，两个变量实际上将引用同一个对象：
```javascript
var obj1 = new Object();
var obj2 = obj1;
obj1.name = "Nicholas";
alert(obj2.name); //"Nicholas"
```

#### 传递参数
在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量：
```javascript
function addTen(num) {
    num += 10;
    return num;
}
var count = 20;
var result = addTen(count);
alert(count); //20，没有变化
alert(result); //30
```
在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部：
```javascript
function setName(obj) {
    obj.name = "Nicholas";
}
var person = new Object();
setName(person);
alert(person.name); //"Nicholas"
```
在这个函数内部，obj和person引用的是同一个对象。当在函数内部重写 obj 时，这
个变量引用的就是一个局部对象了，即使在函数内部修改了参数的值，但原始的引用仍然保持未变：
```javascript
function setName(obj) {
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name); //"Nicholas"
```
> 可以把 ECMAScript 函数的参数想象成局部变量

#### 检测类型
 typeof操作符是确定一个变量是基础类型的最佳工具：
```javascript
var s = "Nicholas";
var b = true;
var i = 22;
var u;
var n = null;
var o = new Object();
alert(typeof s); //string
alert(typeof i); //number
alert(typeof b); //boolean
alert(typeof u); //undefined
alert(typeof n); //object
alert(typeof o); //object
```
检测引用类型（一个实例具体是什么引用类型）：
```javascript
result = variable instanceof constructor

alert(person instanceof Object);  // 变量 person 是 Object 吗？
alert(colors instanceof Array); // 变量 colors 是 Array 吗？
alert(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？
```

### 执行环境及作用域
`执行环境`定义了变量或函数有权访问的其他数据，决定了它们各自的行为。当代码在一个环境中执行时，会创建变量对象的一个`作用域链`，作用域链的用途：保证对执行环境有权访问的所有变量和函数的有序访问。
```javascript
var color = "blue";
function changeColor(){
    if (color === "blue"){
        color = "red";
    } else {
        color = "blue";
    }
}
changeColor();
alert("Color is now " + color);
```
函数 changeColor() 的作用域链包含两个对象：它自己的变量对象（其中定义着arguments对象）和全局环境的变量对象。可以在函数内部访问变量color，就是因为可以在这个作用域链中找到它。在局部作用域中定义的变量可以在局部环境中与全局变量互换使用：
```javascript
var color = "blue";
function changeColor(){
    var anotherColor = "red";
    function swapColors(){
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
        // 这里可以访问 color、anotherColor 和 tempColor
    }
    // 这里可以访问 color 和 anotherColor，但不能访问 tempColor
    swapColors();
}
// 这里只能访问 color
changeColor();
```
内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。

#### 延长作用域链
当执行流进入下列任何一个语句时，作用域链就会得到加长：
- try-catch语句的catch块
- with语句

这两个语句都会在作用域链的前端添加一个变量对象，对with语句来说，会将指定的对象添加到作用域链中：
```javascript
function buildUrl() {
    var qs = "?debug=true";
    with(location){
        var url = href + qs;
    }
    return url;
}
```

#### 没有块级作用域
```javascript
if (true) {
    var color = "blue";
}
alert(color); //"blue"
```
在JavaScript 中，if语句中的变量声明会将变量添加到当前的执行环境。由for语句创建的变量i即使在for循环执行结束后，也依旧会存在于循环外部的执行环境中：
```javascript
for (var i=0; i < 10; i++){
    doSomething(i);
}
alert(i); //10
```

##### 声明变量
使用var声明的变量会自动被添加到最接近的环境中：
```javascript
function add(num1, num2) {
    var sum = num1 + num2;
    return sum;
}
var result = add(10, 20); //30
alert(sum); //由于 sum 不是有效的变量，因此会导致错误
```
如果省略这个例子中的var关键字，那么当add()执行完毕后，sum也将可以访问到：
```javascript
function add(num1, num2) {
    sum = num1 + num2;
    return sum;
}
var result = add(10, 20); //30
alert(sum); //30
```

##### 查询标识符
当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么：
```javascript
var color = "blue";
function getColor(){
    return color;
}
alert(getColor()); //"blue"
```
在这个搜索过程中，如果存在一个局部的变量的定义，则搜索会自动停止，不再进入另一个变量对象：
```javascript
var color = "blue";
function getColor(){
    var color = "red";
    return color;
}
alert(getColor()); //"red"
```
任何位于局部变量color的声明之后的代码，如果不使用window.color都无法访问全局color变量。

### 垃圾收集
#### 标记清除
当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

#### 引用计数
引用计数的含义是跟踪记录每个值被引用的次数，对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用就是循环引用：
```javascript
function problem(){
    var objectA = new Object();
    var objectB = new Object();
    objectA.someOtherObject = objectB;
    objectB.anotherObject = objectA;
}
```
IE的JavaScript引擎是使用标记清除策略来实现的，但JavaScript访问的COM对象依然是基于引用计数策略：
```javascript
var element = document.getElementById("some_element");
var myObject = new Object();
myObject.element = element;
element.someObject = myObject;
```
可以使用下面的代码消除前面例子创建的循环引用：
```javascript
myObject.element = null;
element.someObject = null;
```

#### 管理内存
优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）：
```javascript
function createPerson(name){
    var localPerson = new Object();
    localPerson.name = name;
    return localPerson;
}
var globalPerson = createPerson("Nicholas");
// 手工解除 globalPerson 的引用
globalPerson = null;
```
由于localPerson在createPerson()函数执行完毕后就离开了其执行环境，因此无需我们显式地去为它解除引用，对于全局变量globalPerson而言，则需要我们在不使用它的时候手工为它解除引用。

## 第五章：引用类型
引用类型的值（对象）是引用类型的一个实例，新对象是使用new操作符后跟一个构造函数来创建的，构造函数本身就是一个函数，只不过是出于创建新对象的目的而定义的。

### Object类型
创建Object实例的两种方式：
```javascript
var person = new Object();
person.name = "Nicholas";
person.age = 29;

var person = {
    name : "Nicholas",
    age : 29
};
```
在JavaScript也可以使用方括号表示法来访问对象的属性：
```javascript
alert(person["name"]); //"Nicholas"
alert(person.name); //"Nicholas"
```
方括号语法的优点是可以通过变量来访问属性或者包含会导致语法错误字符的属性名：
```javascript
var propertyName = "name";
alert(person[propertyName]); //"Nicholas"

person["first name"] = "Nicholas";
```

### Array类型
创建数组的基本方式：
```javascript
var colors = new Array();
var colors = new Array(3); // 创建一个包含 3 项的数组
var names = new Array("Greg"); // 创建一个包含 1 项，即字符串"Greg"的数组
var colors = Array(3); // 省略操作符
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
var names = []; // 创建一个空数组
var values = [1,2,]; // 不要这样！这样会创建一个包含 2 或 3 项的数组
var options = [,,,,,]; // 不要这样！这样会创建一个包含 5 或 6 项的数组
```
通过设置数组的length属性，可以从数组的末尾移除项或向数组中添加新项：
```javascript
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
colors.length = 2;
alert(colors[2]); //undefined

var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
colors.length = 4;
alert(colors[3]); //undefined

var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
colors[colors.length] = "black"; // （在位置 3 ）添加一种颜色
colors[colors.length] = "brown"; // （在位置 4 ）再添加一种颜色

var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
colors[99] = "black"; // （在位置 99 ）添加一种颜色
alert(colors.length); // 100
```

#### 检测数组
对于一个网页，或者一个全局作用域而言：
```javascript
if (value instanceof Array){
    //对数组执行某些操作
}
```
多个全局执行环境：
```javascript
if (Array.isArray(value)){
    //对数组执行某些操作
}
```

#### 转换方法
调用数组的`toString()`、`toLocaleString()`方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串，`valueOf()`返回的还是数组：
```javascript
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
alert(colors.toString()); // "red,blue,green"
alert(colors.valueOf()); // ["red","blue","green"]
alert(colors); // "red,blue,green"
```
alert要接受字符串参数，所以它会在后台调用`toString()`方法，而`toString()`、`toLocaleString()`会调用了数组每一项的`toString()`、`toLocaleString()`方法：
```javascript
var person1 = {
    toLocaleString : function () {
        return "Nikolaos";
    },
    toString : function() {
        return "Nicholas";
    }
};
var person2 = {
    toLocaleString : function () {
        return "Grigorios";
    },
    toString : function() {
        return "Greg";
    }
};
var people = [person1, person2];
alert(people); //Nicholas,Greg
alert(people.toString()); //Nicholas,Greg
alert(people.toLocaleString()); //Nikolaos,Grigorios
```
使用join()方法，则可以使用不同的分隔符来构建这个字符串：
```javascript
var colors = ["red", "green", "blue"];
alert(colors.join(",")); //red,green,blue
alert(colors.join("||")); //red||green||blue
```

#### 栈方法
push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项：
```javascript
var colors = new Array(); // 创建一个数组
var count = colors.push("red", "green"); // 推入两项
alert(count); //2
count = colors.push("black"); // 推入另一项
alert(count); //3
var item = colors.pop(); // 取得最后一项
alert(item); //"black"
alert(colors.length); //2
```
可以将栈方法与其他数组方法连用：
```javascript
var colors = ["red", "blue"];
colors.push("brown"); // 添加另一项
colors[3] = "black"; // 添加一项
alert(colors.length); // 4
var item = colors.pop(); // 取得最后一项
alert(item); // "black"
```

#### 队列方法
shift()它能够移除数组中的第一个项并返回该项，同时将数组长度减1：
```javascript
var colors = new Array(); //创建一个数组
var count = colors.push("red", "green"); //推入两项
alert(count); //2
count = colors.push("black"); //推入另一项
alert(count); //3
var item = colors.shift(); // 取得第一项
alert(item); //"red"
alert(colors.length); //2
```
unshift()与shift()的用途相反，它能在数组前端添加任意个项并返回新数组的长度：
```javascript
var colors = new Array(); //创建一个数组
var count = colors.unshift("red", "green"); // 推入两项
alert(count); //2

count = colors.unshift("black"); // 推入另一项
alert(count); //3
var item = colors.pop(); // 取得最后一项
alert(item); //"green"
alert(colors.length); //2
```

#### 重排序方法
reverse()方法会反转数组项的顺序：
```javascript
var values = [1, 2, 3, 4, 5];
values.reverse();
alert(values); // 5,4,3,2,1
```
sort()方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。为了实现排序， sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串：
```javascript
var values = [0, 1, 5, 10, 15];
values.sort();
alert(values); //0,1,10,15,5
```
在进行字符串比较时，"10"则位于"5"的前面，于是数组的顺序就被修改了，因此sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面：
```javascript
// 升序
function compare1(value1, value2) {
    if (value1 < value2) {
        return -1;
    } else if (value1 > value2) {
        return 1;
    } else {
        return 0;
    }
}
var values = [0, 1, 5, 10, 15];
values.sort(compare1);
alert(values); //0,1,5,10,15

// 降序
function compare2(value1, value2) {
    if (value1 < value2) {
        return 1;
    } else if (value1 > value2) {
        return -1;
    } else {
        return 0;
    }
}
values.sort(compare2);
alert(values); // 15,10,5,1,0
```
对于数值类型：
```javascript
function compare(value1, value2){
    return value2 - value1;
}
```

#### 操作方法
concat()方法可以基于当前数组中的所有项创建一个新数组：
- 如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中
- 如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾
- 如果没有给concat()方法传递参数的情况下，它只是复制当前数组并返回副本

```javascript
var colors = ["red", "green", "blue"];
var colors2 = colors.concat("yellow", ["black", "brown"]);
alert(colors); //red,green,blue
alert(colors2); //red,green,blue,yellow,black,brown
```
slice()能够基于当前数组中的一或多个项创建一个新数组，它可以接受一或两个参数，即要返回项的起始和结束位置：
- 如果只有一个参数，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项
- 如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项

```javascript
var colors = ["red", "green", "blue", "yellow", "purple"];
var colors2 = colors.slice(1);
var colors3 = colors.slice(1,4);
var colors4 = colors.slice(-2, -1);
var colors5 = colors.slice(3, 4);
var colors6 = colors.slice(4, 3);
alert(colors2); //green,blue,yellow,purple
alert(colors3); //green,blue,yellow
alert(colors4); // yellow
alert(colors5); // yellow
alert(colors6); // []
```
splice()的主要用途是向数组的中部插入项：
- 删除：指定两个参数，要删除的第一项的位置和要删除的项数
- 插入：提供3个参数：起始位置、0（要删除的项数）和要插入的项
- 替换：指定3个参数：起始位置、要删除的项数和要插入的任意数量的项

```javascript
var colors = ["red", "green", "blue"];
var removed = colors.splice(0,1); // 删除第一项
alert(colors); // green,blue
alert(removed); // red，返回的数组中只包含一项
removed = colors.splice(1, 0, "yellow", "orange"); // 从位置 1 开始插入两项
alert(colors); // green,yellow,orange,blue
alert(removed); // 返回的是一个空数组
removed = colors.splice(1, 1, "red", "purple"); // 插入两项，删除一项
alert(colors); // green,red,purple,orange,blue
alert(removed); // yellow，返回的数组中只包含一项
```

#### 位置方法
indexOf()和lastIndexOf()都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引：
- indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找
- 两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1
- 比较第一个参数与数组中的每一项时，会使用全等操作符

```javascript
var numbers = [1,2,3,4,5,4,3,2,1];
alert(numbers.indexOf(4)); //3
alert(numbers.lastIndexOf(4)); //5
alert(numbers.indexOf(4, 4)); //5
alert(numbers.lastIndexOf(4, 4)); //3
var person = { name: "Nicholas" };
var people = [{ name: "Nicholas" }];
var morePeople = [person];
alert(people.indexOf(person)); //-1
alert(morePeople.indexOf(person)); //0
```

#### 迭代方法
every()和some()，它们都用于查询数组中的项是否满足某个条件：
```javascript
var numbers = [1,2,3,4,5,4,3,2,1];

// every()：传入的函数必须对每一项都返回true，这个方法才返回true
var everyResult = numbers.every(function(item, index, array){
return (item > 2);
});
alert(everyResult); //false

// some()：只要传入的函数对数组中的某一项返回true，就会返回true
var someResult = numbers.some(function(item, index, array){
return (item > 2);
});
alert(someResult); //true
```
filter()利用指定的函数确定是否在返回的数组中包含某一项：
```javascript
var numbers = [1,2,3,4,5,4,3,2,1];
var filterResult = numbers.filter(function(item, index, array){
return (item > 2);
});
alert(filterResult); //[3,4,5,4,3]
```
map()也返回一个数组，而这个数组的每一项都是在原始数组中的对应项上运行传入函数的结果：
```javascript
var numbers = [1,2,3,4,5,4,3,2,1];
var mapResult = numbers.map(function(item, index, array){
return item * 2;
});
alert(mapResult); //[2,4,6,8,10,8,6,4,2]
```
forEach()，它只是对数组中的每一项运行传入的函数：
```javascript
var numbers = [1,2,3,4,5,4,3,2,1];
numbers.forEach(function(item, index, array){
    //执行某些操作
});
```

#### 归并方法
reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项：
```javascript
// 执行求数组中所有值之和的操作
var values = [1,2,3,4,5];
var sum = values.reduce(function(prev, cur, index, array){
return prev + cur;
});
alert(sum); //15

var values = [1,2,3,4,5];
var sum = values.reduceRight(function(prev, cur, index, array){
return prev + cur;
});
alert(sum); //15
```

### Date类型
在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间：
```javascript
var now = new Date();
```
Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数，如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()：
```javascript
// Tue May 25 2004 00:00:00 GMT+0800 (中国标准时间)
var someDate = new Date(Date.parse("May 25, 2004"));
var someDate = new Date("May 25, 2004");
```
Date.UTC()方法同样也返回表示日期的毫秒数：
```javascript
// GMT 时间 2000 年 1 月 1 日午夜零时
var y2k = new Date(Date.UTC(2000, 0));
// GMT 时间 2005 年 5 月 5 日下午 5:55:55
var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));

// 本地时间 2000 年 1 月 1 日午夜零时
var y2k = new Date(2000, 0);
// 本地时间 2005 年 5 月 5 日下午 5:55:55
var allFives = new Date(2005, 4, 5, 17, 55, 55);
```
Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数：
```javascript
//取得开始时间
var start = Date.now();
//调用函数
doSomething();
//取得停止时间
var stop = Date.now(),
result = stop – start;
```

#### 继承的方法
Date类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间，toString()方法则通常返回带有时区信息的日期和时间，Date类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示：
```javascript
var date1 = new Date(2007, 0, 1); //"January 1, 2007"
var date2 = new Date(2007, 1, 1); //"February 1, 2007"
(new Date(2007, 0, 1)).valueOf()  // 1167580800000
(new Date(2007, 0, 1)).valueOf()  // 1170259200000
alert(date1 < date2); //true
alert(date1 > date2); //false
```

### RegExp类型
创建一个正则表达式：
```javascript
var expression = / pattern / flags ;

/*
* 匹配字符串中所有"at"的实例
*/
var pattern1 = /at/g;
/*
* 匹配第一个"bat"或"cat"，不区分大小写
*/
var pattern2 = /[bc]at/i;
/*
* 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写
*/
var pattern3 = /.at/gi;
```
模式中使用的所有元字符都必须转义：
```javascript
/*
* 匹配第一个"bat"或"cat"，不区分大小写
*/
var pattern1 = /[bc]at/i;
/*
* 匹配第一个" [bc]at"，不区分大小写
*/
var pattern2 = /\[bc\]at/i;
/*
* 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写
*/
var pattern3 = /.at/gi;
/*
* 匹配所有".at"，不区分大小写
*/
var pattern4 = /\.at/gi;
```
使用RegExp构造函数创建正则表达式：
```javascript
/*
* 匹配第一个"bat"或"cat"，不区分大小写
*/
var pattern1 = /[bc]at/i;
/*
* 与 pattern1 相同，只不过是使用构造函数创建的
*/
var pattern2 = new RegExp("[bc]at", "i");
```
正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例：
```javascript
var re = null, i;
for (i=0; i < 10; i++){
    re = /cat/g;
    re.test("catastrophe");
}
for (i=0; i < 10; i++){
    re = new RegExp("cat", "g");
    re.test("catastrophe");
}
```

#### RegExp实例属性
通过实例属性可以取得有关模式的各种信息：
```javascript
var pattern1 = /\[bc\]at/i;
alert(pattern1.global); //false
alert(pattern1.ignoreCase); //true
alert(pattern1.multiline); //false
alert(pattern1.lastIndex); //0
alert(pattern1.source); //"\[bc\]at"
var pattern2 = new RegExp("\\[bc\\]at", "i");
alert(pattern2.global); //false
alert(pattern2.ignoreCase); //true
alert(pattern2.multiline); //false
alert(pattern2.lastIndex); //0
alert(pattern2.source); //"\[bc\]at"
```

#### RegExp实例方法
exec()是专门为捕获组而设计的，exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null：
```javascript
var text = "mom and dad and baby";
var pattern = /mom( and dad( and baby)?)?/gi;
var matches = pattern.exec(text);
alert(matches.index); // 0
alert(matches.input); // "mom and dad and baby"
alert(matches[0]); // "mom and dad and baby"
alert(matches[1]); // " and dad and baby"
alert(matches[2]); // " and baby"
```
test()接受一个字符串参数，在模式与该参数匹配的情况下返回true；否则，返回false：
```javascript
var text = "000-00-0000";
var pattern = /\d{3}-\d{2}-\d{4}/;
if (pattern.test(text)){
    alert("The pattern was matched.");
}
```

#### RegExp构造函数属性
```javascript
var text = "this has been a short summer";
var pattern = /(.)hort/g;
/*
* 注意：Opera 不支持 input、lastMatch、lastParen 和 multiline 属性
* Internet Explorer 不支持 multiline 属性
*/
if (pattern.test(text)){
alert(RegExp.input); // this has been a short summer
alert(RegExp.leftContext); // this has been a
alert(RegExp.rightContext); // summer
alert(RegExp.lastMatch); // short
alert(RegExp.lastParen); // s
alert(RegExp.multiline); // false
}
```

### Function类型
函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定：
```javascript
function sum(num1, num2){
return num1 + num2;
}
alert(sum(10,10)); //20
var anotherSum = sum;
alert(anotherSum(10,10)); //20
sum = null;
alert(anotherSum(10,10)); //20
```

#### 没有重载
```javascript
function addSomeNumber(num){
    return num + 100;
}
function addSomeNumber(num) {
    return num + 200;
}
var result = addSomeNumber(100); //300
```
这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数，等同于：
```javascript
var addSomeNumber = function (num){
    return num + 100;
};
addSomeNumber = function (num) {
    return num + 200;
};
var result = addSomeNumber(100); //300
```

#### 函数声明与函数表达式
解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行：
```javascript
alert(sum(10,10));
function sum(num1, num2){
    return num1 + num2;
}

alert(sum(10,10)); // unexpected identifier
var sum = function(num1, num2){
    return num1 + num2;
};
```

#### 作为值的函数
不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回：
```javascript
function callSomeFunction(someFunction, someArgument){
    return someFunction(someArgument);
}
function add10(num){
    return num + 10;
}
var result1 = callSomeFunction(add10, 10);
alert(result1); //20
function getGreeting(name){
    return "Hello, " + name;
}
var result2 = callSomeFunction(getGreeting, "Nicholas");
alert(result2); //"Hello, Nicholas"
```
可以从一个函数中返回另一个函数：
```javascript
function createComparisonFunction(propertyName) {
    return function(object1, object2){
        var value1 = object1[propertyName];
        var value2 = object2[propertyName];
        if (value1 < value2){
            return -1;
        } else if (value1 > value2){
            return 1;
        } else {
            return 0;
        }
    };
}

var data = [{name: "Zachary", age: 28}, {name: "Nicholas", age: 29}];
data.sort(createComparisonFunction("name"));
alert(data[0].name); //Nicholas
data.sort(createComparisonFunction("age"));
alert(data[0].name); //Zachary
```

#### 函数内部属性
arguments.callee拥有这个arguments对象的函数，利用它可以解除函数体内的代
码与函数名的耦合状态：
```javascript
function factorial(num){
    if (num <=1) {
        return 1;
    } else {
        return num * arguments.callee(num-1)
    }
}
var trueFactorial = factorial;
factorial = function(){
    return 0;
};
alert(trueFactorial(5)); //120
alert(factorial(5)); //0
```
this引用的是函数据以执行的环境对象：
```javascript
window.color = "red";
var o = { color: "blue" };
function sayColor(){
    alert(this.color);
}
sayColor(); //"red"
o.sayColor = sayColor;
o.sayColor(); //"blue"
```
caller保存着调用当前函数的函数的引用：
```javascript
function outer(){
    inner();
}
function inner(){
    alert(inner.caller);
    // alert(arguments.callee.caller);
}
outer();
```

#### 函数属性和方法
每个函数都包含两个属性：length和prototype。其中，length属性表示函数希望接收的命名参数的个数：
```javascript
function sayName(name){
    alert(name);
}
function sum(num1, num2){
    return num1 + num2;
}
function sayHi(){
    alert("hi");
}
alert(sayName.length); //1
alert(sum.length); //2
alert(sayHi.length); //0
```
apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象：
```javascript
function sum(num1, num2){
    return num1 + num2;
}
function callSum1(num1, num2){
    return sum.apply(this, arguments); // 传入 arguments 对象
}
function callSum2(num1, num2){
    return sum.apply(this, [num1, num2]); // 传入数组
}
alert(callSum1(10,10)); //20
alert(callSum2(10,10)); //20
```
在使用call()方法时，传递给函数的参数必须逐个列举出来：
```javascript
function sum(num1, num2){
    return num1 + num2;
}
function callSum(num1, num2){
    return sum.call(this, num1, num2);
}
alert(callSum(10,10)); //20
```
apply()和call()真正强大的地方是能够扩充函数赖以运行的作用域（设置函数体内this对象的值）：
```javascript
window.color = "red";
var o = { color: "blue" };
function sayColor(){
    alert(this.color);
}
sayColor(); //red
sayColor.call(this); //red
sayColor.call(window); //red
sayColor.call(o); //blue
```
bind()方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值：
```javascript
window.color = "red";
var o = { color: "blue" };
function sayColor(){
    alert(this.color);
}
var objectSayColor = sayColor.bind(o);
objectSayColor(); //blue
```
> 每个函数继承的toLocaleString()、toString()、valueOf()方法始终都返回函数的代码

### 基本包装类型
每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象：
```javascript
var s1 = "some text";
var s2 = s1.substring(2);

// 执行上述代码时，后台完成如下处理
var s1 = new String("some text");
var s2 = s1.substring(2);
s1 = null;
```
使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁：
```javascript
var s1 = "some text";
s1.color = "red";
alert(s1.color); //undefined
```
对基本包装类型的实例调用typeof会返回"object"，而且所有基本包装类型的对象都会被转换为布尔值true：
```javascript
var str = new String("aaa");
alert(typeof str); // object

Boolean(new Number(0)); // true
Boolean(new Boolean(false)); // true
Boolean(new String("aaa")) // true
```
Object构造函数根据传入值的类型返回相应基本包装类型的实例：
```javascript
var obj = new Object("some text");
alert(obj instanceof String); //true
```
使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的：
```javascript
var value = "25";
var number = Number(value); //转型函数
alert(typeof number); //"number"
var obj = new Number(value); //构造函数
alert(typeof obj); //"object"
```

#### Boolean类型
Boolean类型的实例重写了valueOf()方法，返回基本类型值true或false；重写了toString()方法，返回字符串"true"和"false"：
```javascript
var booleanObject = new Boolean(true);
alert(booleanObject.valueOf()); // true
alert(booleanObject.toString()); // "true"
```
Boolean在ECMAScript中的用处不大，因为布尔表达式中的所有对象都会被转换为true：
```javascript
var falseObject = new Boolean(false);
var result = falseObject && true;
alert(result); //true

var falseValue = false;
result = falseValue && true;
alert(result); //false
```
另外两个区别：
```javascript
alert(typeof falseObject); //object
alert(typeof falseValue); //boolean
alert(falseObject instanceof Boolean); //true
alert(falseValue instanceof Boolean); //false
```

#### Number类型
Number类型也重写了valueOf()、toLocaleString()和toString()方法：
```javascript
var numberObject = new Number(10);
alert(numberObject.valueOf()); // 10
alert(numberObject.toString()); // "10"
alert(numberObject.toLocaleString()); // "10"
```
可以为toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式：
```javascript
var num = 10;
alert(num.toString()); //"10"
alert(num.toString(2)); //"1010"
alert(num.toString(8)); //"12"
alert(num.toString(10)); //"10"
alert(num.toString(16)); //"a"
```
toFixed()方法会按照指定的小数位返回数值的字符串表示，如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就会舍入：
```javascript
var num = 10;
alert(num.toFixed(2)); //"10.00"

var num = 10.005;
alert(num.toFixed(2)); //"10.01"
```
toExponential()，该方法返回以指数表示法（也称e表示法）表示的数值的字符串形式，toExponential()也接收一个参数，而且该参数同样也是指定输出结果中的小数位数：
```javascript
var num = 10;
alert(num.toExponential(1)); //"1.0e+1"
```
toPrecision()方法可能会返回固定大小（fixed）格式，也可能返回指数（exponential）格式：
```javascript
var num = 99;
alert(num.toPrecision(1)); //"1e+2"
alert(num.toPrecision(2)); //"99"
alert(num.toPrecision(3)); //"99.0"
```
不建议直接实例化Number类型，在使用typeof和instanceof操作符测试基本类型数值与引用类型数值时，得到的结果完全不同：
```javascript
var numberObject = new Number(10);
var numberValue = 10;
alert(typeof numberObject); //"object"
alert(typeof numberValue); //"number"
alert(numberObject instanceof Number); //true
alert(numberValue instanceof Number); //false
```

#### String类型
String类型是字符串的对象包装类型，继承的valueOf()、toLocale-String()和toString()方法，都返回对象所表示的基本字符串值：
```javascript
var stringObject = new String("hello world");
alert(stringObject.valueOf()); // "hello world"
alert(stringObject.toString()); // "hello world"
alert(stringObject.toLocaleString()); // "hello world"
```
String类型的每个实例都有一个length属性，表示字符串中包含多个字符：
```javascript
var stringValue = "hello world";
alert(stringValue.length); //"11"
```

##### 字符方法
```javascript
var stringValue = "hello world";
alert(stringValue.charAt(1)); // "e"

var stringValue = "hello world";
alert(stringValue.charCodeAt(1)); // 输出"101"

var stringValue = "hello world";
alert(stringValue[1]); //"e"
```

##### 字符串操作方法
concat()用于将一或多个字符串拼接起来，返回拼接得到的新字符串：
```javascript
var stringValue = "hello ";
var result = stringValue.concat("world");
alert(result); //"hello world"
alert(stringValue); //"hello"

var stringValue = "hello ";
var result = stringValue.concat("world", "!");
alert(result); //"hello world!"
alert(stringValue); //"hello"
```
slice()、substr()和substring()这三个方法都会返回被操作字符串的一个子字符串：
```javascript
var stringValue = "hello world";
alert(stringValue.slice(3)); //"lo world"
alert(stringValue.substring(3)); //"lo world"
alert(stringValue.substr(3)); //"lo world"
alert(stringValue.slice(3, 7)); //"lo w"
alert(stringValue.substring(3,7)); //"lo w"
alert(stringValue.substr(3, 7)); //"lo worl"
```
在传递给这些方法的参数是负值的情况下，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。最后，substring()方法会把所有负值参数都转换为0：
```javascript
var stringValue = "hello world";
alert(stringValue.slice(-3)); //"rld"
alert(stringValue.substring(-3)); //"hello world"
alert(stringValue.substr(-3)); //"rld"
alert(stringValue.slice(3, -4)); //"lo w"
alert(stringValue.substring(3, -4)); //"hel"
alert(stringValue.substr(3, -4)); //"" （空字符串）
```

##### 字符串位置方法
indexOf()方法从字符串的开头向后搜索子字符串，而lastIndexOf()方法是从字符串的末尾向前搜索子字符串：
```javascript
var stringValue = "hello world";
alert(stringValue.indexOf("o")); //4
alert(stringValue.lastIndexOf("o")); //7

var stringValue = "hello world";
alert(stringValue.indexOf("o", 6)); //7
alert(stringValue.lastIndexOf("o", 6)); //4
```
在使用第二个参数的情况下，可以通过循环调用indexOf()或lastIndexOf()来找到所有匹配的子字符串：
```javascript
var stringValue = "Lorem ipsum dolor sit amet, consectetur adipisicing elit";
var positions = new Array();
var pos = stringValue.indexOf("e");
while(pos > -1){
positions.push(pos);
pos = stringValue.indexOf("e", pos + 1);
}
alert(positions); //"3,24,32,35,52"
```

##### trim()方法
trim()方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果：
```javascript
var stringValue = " hello world ";
var trimmedStringValue = stringValue.trim();
alert(stringValue); //"hello world"
alert(trimmedStringValue); //"hello world"
```

##### 字符串大小写转换方法
```javascript
var stringValue = "hello world";
alert(stringValue.toLocaleUpperCase()); //"HELLO WORLD"
alert(stringValue.toUpperCase()); //"HELLO WORLD"
alert(stringValue.toLocaleLowerCase()); //"hello world"
alert(stringValue.toLowerCase()); //"hello world"
```

##### 字符串的模式匹配方法
match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象：
```javascript
var text = "cat, bat, sat, fat";
var pattern = /.at/;
//与 pattern.exec(text)相同
var matches = text.match(pattern);
alert(matches.index); //0
alert(matches[0]); //"cat"
alert(pattern.lastIndex); //0
```
search()方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1：
```javascript
var text = "cat, bat, sat, fat";
var pos = text.search(/at/);
alert(pos); //1
```
replace()方法简化了替换子字符串的操作：
```javascript
var text = "cat, bat, sat, fat";
var result = text.replace("at", "ond");
alert(result); //"cond, bat, sat, fat"
result = text.replace(/at/g, "ond");
alert(result); //"cond, bond, sond, fond"

var text = "cat, bat, sat, fat";
result = text.replace(/(.at)/g, "word ($1)");
alert(result); //word (cat), word (bat), word (sat), word (fat)

// 第二个参数也可以是函数
function htmlEscape(text){
    return text.replace(/[<>"&]/g, function(match, pos, originalText){
        switch(match){
            case "<":
                return "&lt;";
            case ">":
                return "&gt;";
            case "&":
                return "&amp;";
            case "\"":
                return "&quot;";
        }
    });
}
alert(htmlEscape("<p class=\"greeting\">Hello world!</p>"));
//&lt;p class=&quot;greeting&quot;&gt;Hello world!&lt;/p&gt;
```
split()方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中：
```javascript
var colorText = "red,blue,green,yellow";
var colors1 = colorText.split(","); //["red", "blue", "green", "yellow"]
var colors2 = colorText.split(",", 2); //["red", "blue"]
var colors3 = colorText.split(/[^\,]+/); //["", ",", ",", ",", ""]
```

##### localeCompare()方法
```javascript
var stringValue = "yellow";
alert(stringValue.localeCompare("brick")); //1
alert(stringValue.localeCompare("yellow")); //0
alert(stringValue.localeCompare("zoo")); //-1
```
因为localeCompare()返回的数值取决于实现，所以最好是像下面例子所示的这样使用这个方法：
```javascript
function determineOrder(value) {
    var result = stringValue.localeCompare(value);
    if (result < 0) {
        alert("The string 'yellow' comes before the string '" + value + "'.");
    } else if (result > 0) {
        alert("The string 'yellow' comes after the string '" + value + "'.");
    } else {
        alert("The string 'yellow' is equal to the string '" + value + "'.");
    }
}
determineOrder("brick");
determineOrder("yellow");
determineOrder("zoo");
```

##### fromCharCode()方法
```javascript
alert(String.fromCharCode(104, 101, 108, 108, 111)); //"hello"
```

### 单体内置对象
#### Global对象
##### URL编码方法
```javascript
var uri = "http://www.wrox.com/illegal value.htm#start";
//"http://www.wrox.com/illegal%20value.htm#start"
alert(encodeURI(uri));
//"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"
alert(encodeURIComponent(uri));

var uri = "http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start";
//http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23start
alert(decodeURI(uri));
//http://www.wrox.com/illegal value.htm#start
alert(decodeURIComponent(uri));
```

##### eval()方法
```javascript
eval("alert('hi')"); // alert("hi");

var msg = "hello world";
eval("alert(msg)"); //"hello world"

eval("function sayHi() { alert('hi'); }");
sayHi();

eval("var msg = 'hello world'; ");
alert(msg); //"hello world"

"use strict";
eval = "hi"; //causes error
```

##### window对象
```javascript
var color = "red";
function sayColor(){
    alert(window.color);
}
window.sayColor(); //"red"
```
通过创建一个立即调用的函数表达式来取得Global对象：
```javascript
var global = function(){
    return this;
}();
```

#### Math对象
min()和max()方法用于确定一组数值中的最小值和最大值：
```javascript
var max = Math.max(3, 54, 32, 16);
alert(max); //54
var min = Math.min(3, 54, 32, 16);
alert(min); //3

var values = [1, 2, 3, 4, 5, 6, 7, 8];
var max = Math.max.apply(Math, values);
```
Math.ceil()、Math.floor()和Math.round()都能将小数值舍入为整数：
```javascript
alert(Math.ceil(25.9)); //26
alert(Math.ceil(25.5)); //26
alert(Math.ceil(25.1)); //26
alert(Math.round(25.9)); //26
alert(Math.round(25.5)); //26
alert(Math.round(25.1)); //25
alert(Math.floor(25.9)); //25
alert(Math.floor(25.5)); //25
alert(Math.floor(25.1)); //25
```
Math.random()方法返回大于等于0小于1的一个随机数：
```javascript
var num = Math.floor(Math.random() * 10 + 1);

function selectFrom(lowerValue, upperValue) {
var choices = upperValue - lowerValue + 1;
return Math.floor(Math.random() * choices + lowerValue);
}
var num = selectFrom(2, 10);
alert(num); // 介于 2 和 10 之间（包括 2 和 10）的一个数值

var colors = ["red", "green", "blue", "yellow", "black", "purple", "brown"];
var color = colors[selectFrom(0, colors.length-1)];
alert(color); // 可能是数组中包含的任何一个字符串
```

## 第六章：面向对象的程序设计
ECMA-262的对象定义：“无序属性的集合，其属性可以包含基本值、对象或者函数。”

### 理解对象
创建自定义对象：
```javascript
// 创建一个 Object 的实例
var person = new Object();
person.name = "Nicholas";
person.age = 29;
person.job = "Software Engineer";
person.sayName = function(){
    alert(this.name);
};

// 对象字面量
var person = {
    name: "Nicholas",
    age: 29,
    job: "Software Engineer",
    sayName: function(){
        alert(this.name);
    }
};
```

#### 属性类型
ECMAScript中有两种属性：数据属性和访问器属性。

##### 数据属性
直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]和[[Writable]]特性都被设置为true，而[[Value]]特性被设置为指定的值：
```javascript
var person = {
    name: "Nicholas"
};
```
修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty()方法：
```javascript
// "Nicholas"是只读的，这个属性的值是不可修改的
var person = {};
Object.defineProperty(person, "name", {
    writable: false,
    value: "Nicholas"
});
alert(person.name); //"Nicholas"
person.name = "Greg";
alert(person.name); //"Nicholas"

// "Nicholas"是不可配置的，不能从对象中删除属性
var person = {};
Object.defineProperty(person, "name", {
    configurable: false,
    value: "Nicholas"
});
alert(person.name); //"Nicholas"
delete person.name;
alert(person.name); //"Nicholas"

// 一旦把属性定义为不可配置的，就不能再把它变回可配置了
var person = {};
Object.defineProperty(person, "name", {
    configurable: false,
    value: "Nicholas"
});
//抛出错误
Object.defineProperty(person, "name", {
    configurable: true,
    value: "Nicholas"
});
```

##### 访问器属性
在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据：
```javascript
var book = {
    _year: 2004,
    edition: 1
};
Object.defineProperty(book, "year", {
    get: function(){
        return this._year;
    },
    set: function(newValue){
        if (newValue > 2004) {
            this._year = newValue;
            this.edition += newValue - 2004;
        }
    }
});
book.year = 2005;
alert(book.edition); //2
```

#### 定义多个属性
利用Object.definePro-perties()方法可以通过描述符一次定义多个属性：
```javascript
var book = {};
Object.defineProperties(book, {
    _year: {
        value: 2004
    },
    edition: {
        value: 1
    },
    year: {
        get: function(){
            return this._year;
        },
        set: function(newValue){
            if (newValue > 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    }
});
```

#### 读取属性的特性
Object.getOwnPropertyDescriptor()方法可以取得给定属性的描述符：
```javascript
var book = {};
Object.defineProperties(book, {
    _year: {
        value: 2004
    },
    edition: {
        value: 1
    },
    year: {
        get: function(){
            return this._year;
        },
        set: function(newValue){
            if (newValue > 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    }
});
var descriptor = Object.getOwnPropertyDescriptor(book, "_year");
alert(descriptor.value); //2004
alert(descriptor.configurable); //false
alert(typeof descriptor.get); //"undefined"

var descriptor = Object.getOwnPropertyDescriptor(book, "year");
alert(descriptor.value); //undefined
alert(descriptor.enumerable); //false
alert(typeof descriptor.get); //"function"
```

### 创建对象
#### 工厂模式
工厂模式抽象了创建具体对象的过程，用函数来封装以特定接口创建对象的细节（虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题）：
```javascript
function createPerson(name, age, job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    };
    return o;
}
var person1 = createPerson("Nicholas", 29, "Software Engineer");
var person2 = createPerson("Greg", 27, "Doctor");
```

#### 构造函数模式
```javascript
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
        alert(this.name);
    };
}
var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");
```
person1和person2都有一个constructor（构造函数）属性，该属性指向Person：
```javascript
alert(person1.constructor == Person); //true
alert(person2.constructor == Person); //true
```
在这个例子中创建的所有对象既是Object的实例，同时也是Person的实例：
```javascript
alert(person1 instanceof Object); //true
alert(person1 instanceof Person); //true
alert(person2 instanceof Object); //true
alert(person2 instanceof Person); //true
```

##### 将构造函数当作函数
任何函数，只要通过new操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过new操作符来调用，那它跟普通函数也不会有什么两样：
```javascript
// 当作构造函数使用
var person = new Person("Nicholas", 29, "Software Engineer");
person.sayName(); //"Nicholas"
// 作为普通函数调用
Person("Greg", 27, "Doctor"); // 添加到 window
window.sayName(); //"Greg"
// 在另一个对象的作用域中调用
var o = new Object();
Person.call(o, "Kristen", 25, "Nurse");
o.sayName(); //"Kristen"
```

##### 构造函数的问题
使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例：
```javascript
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = new Function("alert(this.name)"); // 与声明函数在逻辑上是等价的
}

alert(person1.sayName == person2.sayName); // false
```
可以通过把函数定义转移到构造函数外部来解决这个问题：
```javascript
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = sayName;
}
function sayName(){
    alert(this.name);
}
var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");
```
在全局作用域中定义的函数实际上只能被某个对象调用，如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了，这些问题可以通过使用原型模式来解决。

#### 原型模式
prototype （原型）属性指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法，使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法：
```javascript
function Person(){

}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
    alert(this.name);
};
var person1 = new Person();
person1.sayName(); //"Nicholas"
var person2 = new Person();
person2.sayName(); //"Nicholas"
alert(person1.sayName == person2.sayName); //true
```

##### 理解原型对象
所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针：
```javascript
Person.prototype.constructor = Person // true
```
当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性[[Prototype]]），指向构造函数的原型对象，如果 [[Prototype]]指向调用isPrototypeOf()方法的对象（Person.prototype），那么这个方法就返回true：
```javascript
alert(Person.prototype.isPrototypeOf(person1)); //true
alert(Person.prototype.isPrototypeOf(person2)); //true
```
Object.getPrototypeOf()返回[[Prototype]]的值：
```javascript
alert(Object.getPrototypeOf(person1) == Person.prototype); //true
alert(Object.getPrototypeOf(person1).name); //"Nicholas"
```
可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值，在实例中创建该属性，该属性将会屏蔽原型中的那个属性：
```javascript
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
    alert(this.name);
};
var person1 = new Person();
var person2 = new Person();
person1.name = "Greg";
alert(person1.name); //"Greg" —— 来自实例
alert(person2.name); //"Nicholas" —— 来自原型
```
使用delete操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性：
```javascript
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
    alert(this.name);
};
var person1 = new Person();
var person2 = new Person();
person1.name = "Greg";
alert(person1.name); //"Greg" —— 来自实例
alert(person2.name); //"Nicholas" —— 来自原型
delete person1.name;
alert(person1.name); //"Nicholas" —— 来自原型
```
hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中：
```javascript
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
    alert(this.name);
};
var person1 = new Person();
var person2 = new Person();
alert(person1.hasOwnProperty("name")); //false
person1.name = "Greg";
alert(person1.name); //"Greg"——来自实例
alert(person1.hasOwnProperty("name")); //true
alert(person2.name); //"Nicholas"——来自原型
alert(person2.hasOwnProperty("name")); //false
delete person1.name;
alert(person1.name); //"Nicholas"——来自原型
alert(person1.hasOwnProperty("name")); //false    
```

##### 原型与in操作符
in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中：
```javascript
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
    alert(this.name);
};
var person1 = new Person();
var person2 = new Person();
alert(person1.hasOwnProperty("name")); //false
alert("name" in person1); //true
person1.name = "Greg";
alert(person1.name); //"Greg" ——来自实例
alert(person1.hasOwnProperty("name")); //true
alert("name" in person1); //true
alert(person2.name); //"Nicholas" ——来自原型
alert(person2.hasOwnProperty("name")); //false
alert("name" in person2); //true
delete person1.name;
alert(person1.name); //"Nicholas" ——来自原型
alert(person1.hasOwnProperty("name")); //false
alert("name" in person1); //true
```
同时使用`hasOwnProperty()`方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中：
```javascript
function hasPrototypeProperty(object, name){
    return !object.hasOwnProperty(name) && (name in object);
}
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
    alert(this.name);
};
var person = new Person();
alert(hasPrototypeProperty(person, "name")); //true
person.name = "Greg";
alert(hasPrototypeProperty(person, "name")); //false
```
Object.keys()方法可以取得对象上所有可枚举的实例属性：
```javascript
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
    alert(this.name);
};
var keys = Object.keys(Person.prototype);
alert(keys); //"name,age,job,sayName"
var p1 = new Person();
p1.name = "Rob";
p1.age = 31;
var p1keys = Object.keys(p1);
alert(p1keys); //"name,age"
```
Object.getOwnPropertyNames()得到所有实例属性，无论它是否可枚举：
```javascript
var keys = Object.getOwnPropertyNames(Person.prototype);
alert(keys); //"constructor,name,age,job,sayName"
```

##### 更简单的原型语法
用一个包含所有属性和方法的对象字面量来重写整个原型对象，重写后constructor属性不再指向Person了：
```javascript
function Person(){
}
Person.prototype = {
    name : "Nicholas",
    age : 29,
    job: "Software Engineer",
    sayName : function () {
        alert(this.name);
    }
}; 

var friend = new Person();
alert(friend instanceof Object); //true
alert(friend instanceof Person); //true
alert(friend.constructor == Person); //false
alert(friend.constructor == Object); //true
```
可以将constructor属性的值重设为Person：
```javascript
function Person(){
}
Person.prototype = {
    constructor : Person,
    name : "Nicholas",
    age : 29,
    job: "Software Engineer",
    sayName : function () {
        alert(this.name);
    }
};
```
或者可以使用Object.defineProperty()：
```javascript
// 重设构造函数，只适用于 ECMAScript 5  兼容的浏览器
Object.defineProperty(Person.prototype, "constructor", {
    enumerable: false,
    value: Person
});
```

##### 原型的动态性
对原型对象所做的任何修改都能够立即从实例上反映出来：
```javascript
var friend = new Person();
Person.prototype.sayHi = function(){
    alert("hi");
};
friend.sayHi(); //"hi"（没有问题！）
```
如果重写整个原型对象，切断了现有原型与任何之前已经存在的对象实例之间的联系，它们引用的仍然是最初的原型：
```javascript
function Person(){
}
var friend = new Person();
Person.prototype = {
    constructor: Person,
    name : "Nicholas",
    age : 29,
    job : "Software Engineer",
    sayName : function () {
        alert(this.name);
    }
};
friend.sayName(); //error
```

##### 原生对象的原型
所有原生引用类型（Object、Array、String等）都在其构造函数的原型上定义了方法：
```javascript
alert(typeof Array.prototype.sort); //"function"
alert(typeof String.prototype.substring); //"function"

String.prototype.startsWith = function (text) {
    return this.indexOf(text) == 0;
};
var msg = "Hello world!";
alert(msg.startsWith("Hello")); //true
```

##### 原型对象的问题
```javascript
function Person(){
}
Person.prototype = {
    constructor: Person,
    name : "Nicholas",
    age : 29,
    job : "Software Engineer",
    friends : ["Shelby", "Court"],
    sayName : function () {
        alert(this.name);
    }
};
var person1 = new Person();
var person2 = new Person();
person1.friends.push("Van");
alert(person1.friends); //"Shelby,Court,Van"
alert(person2.friends); //"Shelby,Court,Van"
alert(person1.friends === person2.friends); //true
```
修改了person1.friends引用的数组也会通过person2.friends（与person1.friends指向同一个数组）反映出来。

#### 组合使用构造函数模式和原型模式
构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性：
```javascript
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = ["Shelby", "Court"];
}
Person.prototype = {
    constructor : Person,
    sayName : function(){
        alert(this.name);
    }
}
var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");
person1.friends.push("Van");
alert(person1.friends); //"Shelby,Count,Van"
alert(person2.friends); //"Shelby,Count"
alert(person1.friends === person2.friends); //false
alert(person1.sayName === person2.sayName); //true
```

#### 动态原型模式
```javascript
function Person(name, age, job){
    //属性
    this.name = name;
    this.age = age;
    this.job = job;
    // 方法
    if (typeof this.sayName != "function"){
            Person.prototype.sayName = function(){
            alert(this.name);
        };
    }
}
var friend = new Person("Nicholas", 29, "Software Engineer");
friend.sayName();
```

#### 寄生构造函数模式
基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象：
```javascript
function Person(name, age, job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    };
    return o;
}
var friend = new Person("Nicholas", 29, "Software Engineer");
friend.sayName(); //"Nicholas"
```
创建一个具有额外方法的特殊数组。由于不能直接修改Array构造函数，因此可以使用这个模式：
```javascript
function SpecialArray(){
    //创建数组
    var values = new Array();
    //添加值
    values.push.apply(values, arguments);
    //添加方法
    values.toPipedString = function(){
        return this.join("|");
    };
    //返回数组
    return values;
}
var colors = new SpecialArray("red", "blue", "green");
alert(colors.toPipedString()); //"red|blue|green"
```

#### 稳妥构造函数模式
稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象：
```javascript
function Person(name, age, job){
    //创建要返回的对象
    var o = new Object();
    //可以在这里定义私有变量和函数
    //添加方法
    o.sayName = function(){
        alert(name);
    };
    //返回对象
    return o;
}
var friend = Person("Nicholas", 29, "Software Engineer");
friend.sayName(); //"Nicholas"
```
变量friend中保存的是一个稳妥对象，而除了调用sayName()方法外，没有别的方式可以访问其数据成员

### 继承
#### 原型链
原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法，基本模式代码大致如下：
```javascript
function SuperType(){
    this.property = true;
}
SuperType.prototype.getSuperValue = function(){
    return this.property;
};
function SubType(){
    this.subproperty = false;
}
//继承了 SuperType
SubType.prototype = new SuperType();
SubType.prototype.getSubValue = function (){
    return this.subproperty;
};
var instance = new SubType();
alert(instance.getSuperValue()); //true
```

##### 别忘记默认的原型
所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。SubType继承了SuperType，而SuperType继承了Object。当调用instance.toString()时，实际上调用的是保存在Object.prototype中的那个方法。

##### 确定原型和实例的关系
```javascript
alert(instance instanceof Object); //true
alert(instance instanceof SuperType); //true
alert(instance instanceof SubType); //true

alert(Object.prototype.isPrototypeOf(instance)); //true
alert(SuperType.prototype.isPrototypeOf(instance)); //true
alert(SubType.prototype.isPrototypeOf(instance)); //true
```

##### 谨慎地定义方法
给原型添加或重写方法的代码一定要放在替换原型的语句之后，并且不能使用对象字面量创建原型方法：
```javascript
function SuperType(){
    this.property = true;
}
SuperType.prototype.getSuperValue = function(){
    return this.property;
};
function SubType(){
    this.subproperty = false;
}
//继承了 SuperType
SubType.prototype = new SuperType();
// 添加新方法
SubType.prototype.getSubValue = function (){
    return this.subproperty;
};
// 重写超类型中的方法
SubType.prototype.getSuperValue = function (){
    return false;
};
var instance = new SubType();
alert(instance.getSuperValue()); //false

// 使用字面量添加新方法，会导致上一行代码无效
SubType.prototype = {
    getSubValue : function (){
        return this.subproperty;
    },
    someOtherMethod : function (){
        return false;
    }
};
var instance = new SubType();
alert(instance.getSuperValue()); //error!
```

##### 原型链的问题
在通过原型来实现继承时，原型实际上会变成另一个类型的实例：
```javascript
function SuperType(){
    this.colors = ["red", "blue", "green"];
}
function SubType(){
}
//继承了 SuperType
SubType.prototype = new SuperType();
var instance1 = new SubType();
instance1.colors.push("black");
alert(instance1.colors); //"red,blue,green,black"
var instance2 = new SubType();
alert(instance2.colors); //"red,blue,green,black"    
```
原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。

#### 借用构造函数
通过使用apply()和call()方法可以在（将来）新创建的对象上执行构造函数：
```javascript
function SuperType(){
    this.colors = ["red", "blue", "green"];
}
function SubType(){
    // 继承了 SuperType
    SuperType.call(this);
}
var instance1 = new SubType();
instance1.colors.push("black");
alert(instance1.colors); //"red,blue,green,black"
var instance2 = new SubType();
alert(instance2.colors); //"red,blue,green"
```
借用构造函数有一个很大的优势，可以在子类型构造函数中向超类型构造函数传递参数：
```javascript
function SuperType(name){
    this.name = name;
}
function SubType(){
    //继承了 SuperType，同时还传递了参数
    SuperType.call(this, "Nicholas");
    //实例属性
    this.age = 29;
}
var instance = new SubType();
alert(instance.name); //"Nicholas";
alert(instance.age); //29
```

#### 组合继承
组合继承指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式，使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承：
```javascript
function SuperType(name){
    this.name = name;
    this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function(){
    alert(this.name);
};
function SubType(name, age){
    //继承属性
    SuperType.call(this, name);
    this.age = age;
}
//继承方法
SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function(){
    alert(this.age);
};
var instance1 = new SubType("Nicholas", 29);
instance1.colors.push("black");
alert(instance1.colors); //"red,blue,green,black"
instance1.sayName(); //"Nicholas";
instance1.sayAge(); //29
var instance2 = new SubType("Greg", 27);
alert(instance2.colors); //"red,blue,green"
instance2.sayName(); //"Greg";
instance2.sayAge(); //27
```
两个不同的SubType实例既分别拥有自己属性——包括colors属性，又可以使用相同的方法。

#### 原型式继承
借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型：
```javascript
function object(o){
    function F(){}
    F.prototype = o;
    return new F();
}
var person = {
    name: "Nicholas",
    friends: ["Shelby", "Court", "Van"]
};
var anotherPerson = object(person);
anotherPerson.name = "Greg";
anotherPerson.friends.push("Rob");
var yetAnotherPerson = object(person);
yetAnotherPerson.name = "Linda";
yetAnotherPerson.friends.push("Barbie");
alert(person.friends); //"Shelby,Court,Van,Rob,Barbie"
```
person.friends不仅属于person所有，而且也会被anotherPerson以及yetAnotherPerson共享。实际上，这就相当于又创建了person对象的两个副本。
Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象：
```javascript
var person = {
    name: "Nicholas",
    friends: ["Shelby", "Court", "Van"]
};
var anotherPerson = Object.create(person);
anotherPerson.name = "Greg";
anotherPerson.friends.push("Rob");
var yetAnotherPerson = Object.create(person);
yetAnotherPerson.name = "Linda";
yetAnotherPerson.friends.push("Barbie");
alert(person.friends); //"Shelby,Court,Van,Rob,Barbie"

var anotherPerson = Object.create(person, {
    name: {
        value: "Greg"
    }
});
alert(anotherPerson.name); //"Greg"
```

#### 寄生式继承
```javascript
function createAnother(original){
    var clone = object(original); //通过调用函数创建一个新对象
    clone.sayHi = function(){ //以某种方式来增强这个对象
        alert("hi");
    };
    return clone; //返回这个对象
}

var person = {
    name: "Nicholas",
    friends: ["Shelby", "Court", "Van"]
};
var anotherPerson = createAnother(person);
anotherPerson.sayHi(); //"hi"
```

#### 寄生组合式继承
组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部：
```javascript
function SuperType(name){
    this.name = name;
    this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function(){
    alert(this.name);
};
function SubType(name, age){
    SuperType.call(this, name); // 第二次调用 SuperType()
    this.age = age;
}
SubType.prototype = new SuperType(); // 第一次调用 SuperType()
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function(){
    alert(this.age);
};
```
一组在实例上，一组在 SubType 原型中。这就是调用两次SuperType构造函数的结果，不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型：
```javascript
function inheritPrototype(subType, superType){
    var prototype = object(superType.prototype); //创建对象
    prototype.constructor = subType; //增强对象
    subType.prototype = prototype; //指定对象
}
```
调用inherit-Prototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了：
```javascript
function SuperType(name){
    this.name = name;
    this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function(){
    alert(this.name);
};
function SubType(name, age){
    SuperType.call(this, name);
    this.age = age;
}
inheritPrototype(SubType, SuperType);
SubType.prototype.sayAge = function(){
    alert(this.age);
};
```

## 第七章：函数表达式
通过一个非标准的name属性可以访问到给函数指定的名字：
```javascript
// 只在 Firefox、Safari、Chrome 和 Opera 有效
alert(functionName.name); // "functionName"
```
函数声明提升：
```javascript
sayHi();
function sayHi(){
    alert("Hi!");
}

sayHi(); //错误：函数还不存在
var sayHi = function(){
alert("Hi!");
};
```

### 递归
```javascript
function factorial(num){
    if (num <= 1){
        return 1;
    } else {
        return num * factorial(num-1);
    }
}
var anotherFactorial = factorial;
factorial = null;
alert(anotherFactorial(4)); //出错！

// arguments.callee是一个指向正在执行的函数的指针（非严格模式下有效）
function factorial(num){
    if (num <= 1){
        return 1;
    } else {
        return num * arguments.callee(num-1);
    }
}

// 严格模式下也有用
var factorial = (function f(num){
    if (num <= 1){
        return 1;
    } else {
        return num * f(num-1);
    }
});
```

### 闭包
闭包是指有权访问另一个函数作用域中的变量的函数：
```javascript
function createComparisonFunction(propertyName) {
    return function(object1, object2){
        var value1 = object1[propertyName];
        var value2 = object2[propertyName];
        if (value1 < value2){
            return -1;
        } else if (value1 > value2){
            return 1;
        } else {
            return 0;
        }
    };
}

//创建函数
var compareNames = createComparisonFunction("name");
//调用函数
var result = compareNames({ name: "Nicholas" }, { name: "Greg" });
//解除对匿名函数的引用（以便释放内存）
compareNames = null;
```
createComparisonFunction()函数在执行完毕后，其活动对象不会被销毁，直到匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁。

#### 闭包与变量
闭包所保存的是整个变量对象，所以闭包只能取得包含函数中任何变量的最后一个值：
```javascript
function createFunctions(){
    var result = new Array();
    for (var i=0; i < 10; i++){
        result[i] = function(){
            // 每个函数都引用着保存变量 i 的同一个变量对象
            // 所以在每个函数内部 i 的值都是 10
            return i; 
        };
    }
    return result;
}
```
可以通过创建另一个匿名函数强制让闭包的行为符合预期：
```javascript
function createFunctions(){
    var result = new Array();
    for (var i=0; i < 10; i++){
        result[i] = function(num){
            return function(){
                return num;
            };
        }(i);
    }
    return result;
}
```

#### 关于this对象
```javascript
var name = "The Window";
var object = {
    name : "My Object",
    getNameFunc : function(){
        return function(){
            // 内部函数搜索this和arguments只搜索到活动对象为止
            return this.name; 
        };
    }
};
alert(object.getNameFunc()()); //"The Window"（在非严格模式下）

var name = "The Window";
var object = {
    name : "My Object",
    getNameFunc : function(){
        // 把外部作用域中的this对象保存在一个闭包能够访问到的变量里
        var that = this;
        return function(){
            return that.name;
        };
    }
};
alert(object.getNameFunc()()); //"My Object"

// 特殊情况下，this的值可能会意外地改变
var name = "The Window";
var object = {
    name : "My Object",
    getName: function(){
        return this.name;
    }
};
object.getName(); //"My Object"
(object.getName)(); //"My Object"
(object.getName = object.getName)(); //"The Window"，在非严格模式下
```

#### 内存泄漏
如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁：
```javascript
function assignHandler(){
    var element = document.getElementById("someElement");
    element.onclick = function(){
        alert(element.id);
    };
}
```
即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个引用。因此，有必要把element变量设置为null：
```javascript
function assignHandler(){
    var element = document.getElementById("someElement");
    var id = element.id;
    element.onclick = function(){
        alert(id);
    };
    element = null;
}
```

### 模仿块级作用域
在块语句中定义的变量，实际上是在包含函数中而非语句中创建的：
```javascript
function outputNumbers(count){
    for (var i=0; i < count; i++){
        alert(i);
    }
    alert(i); //计数
}
```
在JavaScrip中，变量i是定义在ouputNumbers()的活动对象中的，因此从它有定义开始，就可以在函数内部随处访问它。匿名函数可以用来模仿块级作用域并避免这个问题：
```javascript
(function(){
//这里是块级作用域
})();

function outputNumbers(count){
    (function () {
        for (var i=0; i < count; i++){
            alert(i);
        }
    })();
    alert(i); //导致一个错误！
}
```

### 私有变量
私有变量包括函数的参数、局部变量和在函数内部定义的其他函数，有权访问私有变量和私有函数的公有方法称为特权方法：
```javascript
// 在构造函数中定义特权方法
function MyObject(){
    //私有变量和私有函数
    var privateVariable = 10;
    function privateFunction(){
        return false;
    }
    //特权方法
    this.publicMethod = function (){
        privateVariable++;
        return privateFunction();
    };
}
```
利用私有和特权成员，可以隐藏那些不应该被直接修改的数据：
```javascript
function Person(name){
    this.getName = function(){
        return name;
    };
    this.setName = function (value) {
        name = value;
    };
}
var person = new Person("Nicholas");
alert(person.getName()); //"Nicholas"
person.setName("Greg");
alert(person.getName()); //"Greg"
```
构造函数模式的缺点是针对每个实例都会创建同样一组新方法

#### 静态私有变量
基本模式：
```javascript
(function(){
    //私有变量和私有函数
    var privateVariable = 10;
    function privateFunction(){
        return false;
    }
    //构造函数
    MyObject = function(){
    };
    //公有/特权方法
    MyObject.prototype.publicMethod = function(){
        privateVariable++;
        return privateFunction();
    };
})();
```
这个特权方法，作为一个闭包，总是保存着对包含作用域的引用：
```javascript
(function(){
    var name = "";
    Person = function(value){
        name = value;
    };
    Person.prototype.getName = function(){
        return name;
    };
    Person.prototype.setName = function (value){
        name = value;
    };
})();
var person1 = new Person("Nicholas");
alert(person1.getName()); //"Nicholas"
person1.setName("Greg");
alert(person1.getName()); //"Greg"
var person2 = new Person("Michael");
alert(person1.getName()); //"Michael"
alert(person2.getName()); //"Michael"
```
以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。

#### 模块模式
模块模式（module pattern）是为单例创建私有变量和特权方法，所谓单例（singleton），指的就是只有一个实例的对象：
```javascript
var singleton = {
    name : value,
    method : function () {
        //这里是方法的代码
    }
};

var singleton = function(){
    //私有变量和私有函数
    var privateVariable = 10;
    function privateFunction(){
        return false;
    }
    //特权/公有方法和属性
    return {
        publicProperty: true,
        publicMethod : function(){
            privateVariable++;
            return privateFunction();
        }
    };
}();
```
如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式：
```javascript
var application = function(){
    //私有变量和函数
    var components = new Array();
    //初始化
    components.push(new BaseComponent());
    //公共
    return {
        getComponentCount : function(){
            return components.length;
        },
        registerComponent : function(component){
            if (typeof component == "object"){
                components.push(component);
            }
        }
    };
}();
```

#### 增强的模块模式
增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况：
```javascript
var singleton = function(){
    //私有变量和私有函数
    var privateVariable = 10;
    function privateFunction(){
        return false;
    }
    //创建对象
    var object = new CustomType();
    //添加特权/公有属性和方法
    object.publicProperty = true;
    object.publicMethod = function(){
        privateVariable++;
        return privateFunction();
    };
    //返回这个对象
    return object;
}();

var application = function(){
    //私有变量和函数
    var components = new Array();
    //初始化
    components.push(new BaseComponent());
    //创建 application 的一个局部副本
    var app = new BaseComponent();
    //公共接口
    app.getComponentCount = function(){
        return components.length;
    };
    app.registerComponent = function(component){
        if (typeof component == "object"){
            components.push(component);
        }
    };
    //返回这个副本
    return app;
}();
```

施工ing。。。